<!doctype html><html lang=zh-tw><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=hugo-theme content="0.7.2"><link rel=icon type=image/png sizes=32x32 href=/images/brand/favicon.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon href=/><link rel=canonical href=https://2020leon.github.io/posts/algorithm-kmp/><link rel=preload as=style href="/bundle.css?v=1601818820" media=all><link rel=stylesheet href="/bundle.css?v=1601818820" media=all><style>.cdata pre{color:#edf2f7;background-color:#2d3748}.cdata :not(pre)>code{color:#805ad5;background-color:#f7fafc}.chroma .err{color:#fed7d7;background-color:#9b2c2c}.chroma .hl{background-color:#4a5568}.chroma .ln{color:#a0aec0}.chroma .k,.chroma .kc,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr{color:#63b3ed}.chroma .kt{color:#b794f4}.chroma .na{color:#f6e05e}.chroma .nb{color:#f6ad55}.chroma .nc{color:#fc8181}.chroma .no{color:#68d391}.chroma .nd{color:#fc8181}.chroma .ne{color:#fc8181}.chroma .nf{color:#f6ad55}.chroma .nt{color:#fc8181}.chroma .l{color:#b794f4}.chroma .dl,.chroma .ld,.chroma .s,.chroma .s2,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .sd{color:#68d391}.chroma .se{color:#a0aec0}.chroma .s1,.chroma .sh,.chroma .si,.chroma .sr,.chroma .ss,.chroma .sx{color:#68d391}.chroma .il,.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .mo{color:#b794f4}.chroma .o,.chroma .ow{color:#90cdf4}.chroma .p{color:#cbd5e0}.chroma .c,.chroma .c1,.chroma .ch,.chroma .cm,.chroma .cp,.chroma .cpf,.chroma .cs{color:#a0aec0}.chroma .ge{font-style:italic}.chroma .gs{font-weight:700}</style><title>[演算法] KMP演算法簡介 - L筆記</title><meta property="og:title" content="[演算法] KMP演算法簡介"><meta property="og:site_name" content="L筆記"><meta property="og:url" content="https://2020leon.github.io/posts/algorithm-kmp/"><link rel=image_src href=https://2020leon.github.io/><meta property="og:image" content="https://2020leon.github.io/"><meta property="og:image:width" content><meta property="og:image:height" content><meta property="og:type" content="article"><meta property="og:locale" content="zh_tw"><meta property="og:description" content="字串搜尋經常出現在日常生活中，因此優化後的字串搜尋演算法必然是大家所追求的目標，而KMP演算法（Knuth–Morris–Pratt algo"><meta name=description content="字串搜尋經常出現在日常生活中，因此優化後的字串搜尋演算法必然是大家所追求的目標，而KMP演算法（Knuth–Morris–Pratt algo"><meta property="og:updated_time" content="2020-10-04T13:40:19Z"><meta property="fb:app_id" content><meta name=author content="Leon Chang"><meta property="article:author" content="https://2020leon.github.io/"><meta property="article:published_time" content="2020-10-04T13:34:38Z"><meta property="article:modified_time" content="2020-10-04T13:40:19Z"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"[演算法] KMP演算法簡介","alternativeHeadline":"優化的字串搜尋演算法","url":"https://2020leon.github.io/posts/algorithm-kmp/","image":"https://2020leon.github.io/","mainEntityOfPage":{"@type":"WebPage","@id":"https://2020leon.github.io/posts/algorithm-kmp/"},"description":"字串搜尋經常出現在日常生活中，因此優化後的字串搜尋演算法必然是大家所追求的目標，而KMP演算法（Knuth–Morris–Pratt algo","author":{"@type":"Person","name":"Leon Chang"},"publisher":{"@type":"Organization","name":"L筆記","logo":{"@type":"ImageObject","url":"https://2020leon.github.io/"}},"datePublished":"2020-10-04T13:34:38Z","dateModified":"2020-10-04T13:40:19Z","articleBody":"\u003cp\u003e字串搜尋經常出現在日常生活中，因此優化後的字串搜尋演算法必然是大家所追求的目標，而\u003cstrong\u003eKMP演算法\u003c/strong\u003e（Knuth–Morris–Pratt algorithm）便是其中之一。在此整理網路上關於KMP的資料。\u003c/p\u003e\n\u003ch2 id=\"符號定義\"\u003e符號定義\u003c/h2\u003e\n\u003cp\u003e字串搜尋便是在\u003cstrong\u003e文字材料\u003c/strong\u003e（text）中找到一些\u003cstrong\u003e字詞\u003c/strong\u003e（pattern）。因此定義\u003ccode\u003eT\u003c/code\u003e代表要搜索的文章（字串），\u003ccode\u003eP\u003c/code\u003e則代表使用者要找的字詞。\u003c/p\u003e\n\u003cp\u003e本文的所有字串都是由零開始的陣列。若\u003ccode\u003eP = \u0026quot;ALGORITHM\u0026quot;\u003c/code\u003e，則\u003ccode\u003eP[1]\u003c/code\u003e是\u003ccode\u003eL\u003c/code\u003e。\u003ccode\u003ei\u003c/code\u003e和\u003ccode\u003ej\u003c/code\u003e分別代表\u003ccode\u003eT\u003c/code\u003e和\u003ccode\u003eP\u003c/code\u003e的索引。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eP[0 ... j]\u003c/code\u003e表示包含\u003ccode\u003e0\u003c/code\u003e但不包含\u003ccode\u003ej\u003c/code\u003e的字元，在數學上用區間表示即是\u003ccode\u003e[0,j)\u003c/code\u003e。若\u003ccode\u003eP = \u0026quot;ALGORITHM\u0026quot;\u003c/code\u003e，則\u003ccode\u003eP[2 ... 5] = \u0026quot;GOR\u0026quot;\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"暴力法\"\u003e暴力法\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e和\u003ccode\u003eP\u003c/code\u003e頭對頭（\u003ccode\u003ei = 0\u003c/code\u003e、\u003ccode\u003ej = 0\u003c/code\u003e），一次取一字一一比對。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若\u003ccode\u003eT[i] == P[j]\u003c/code\u003e，則\u003ccode\u003ei++\u003c/code\u003e、\u003ccode\u003ej++\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e若\u003ccode\u003eT[i] != P[j]\u003c/code\u003e，則\u003ccode\u003ei = i - j + 1\u003c/code\u003e、\u003ccode\u003ej = 0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e時間複雜度\u003cstrong\u003eO(mn)\u003c/strong\u003e，空間複雜度\u003cstrong\u003eO(1)\u003c/strong\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003eT = ABCDAABCDABD\nP = ABCDABD\n----------------\n1.\nT = ABCDAABCDABD\nP = ABCDABD\n    ^^^^^X\n\n2.\nT = ABCDAABCDABD\nP =  ABCDABD\n     X\n\n3.\nT = ABCDAABCDABD\nP =   ABCDABD\n      X\n\n4.\nT = ABCDAABCDABD\nP =    ABCDABD\n       X\n\n5.\nT = ABCDAABCDABD\nP =     ABCDABD\n        ^X\n\n6.\nT = ABCDAABCDABD\nP =      ABCDABD\n         ^^^^^^#\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"改良\"\u003e改良\u003c/h2\u003e\n\u003cp\u003e暴力法的精神便是逐一比對，但事實上不必如此。觀察上方第二至五步，若能一次性將\u003ccode\u003eP\u003c/code\u003e移動至第五步的位置便能\u003cstrong\u003e減少挪動次數\u003c/strong\u003e而增加比對效率，尤其\u003ccode\u003eT\u003c/code\u003e為長字串時效果更為顯著。\u003c/p\u003e\n\u003cp\u003e第一步比對失敗時，\u003ccode\u003ej = 5\u003c/code\u003e。我們發現，可以藉由預先分析\u003ccode\u003eP[0 ... 5] = \u0026quot;ABCDA\u0026quot;\u003c/code\u003e（從\u003ccode\u003eP[0]\u003c/code\u003e到第一步比對失敗\u003cstrong\u003e前\u003c/strong\u003e的子字串）來決定\u003ccode\u003eP\u003c/code\u003e要挪動多少。\u003c/p\u003e\n\u003cp\u003e接下來介紹實現此想法所需的前置作業。\u003c/p\u003e\n\u003ch3 id=\"failure-function\"\u003eFailure Function\u003c/h3\u003e\n\u003cp\u003e中文簡稱\u003cstrong\u003eF函數\u003c/strong\u003e，又稱\u003cstrong\u003eprefix function\u003c/strong\u003e、\u003cstrong\u003eborder function\u003c/strong\u003e。給定一字串，它便會輸出「\u003cstrong\u003e次長相同前綴後綴\u003c/strong\u003e（longest proper prefix-suffix）」的長度。一個字串可能有不只一個「相同前綴後綴（prefix-suffix）」，而「最長相同前綴後綴」肯定是字串本身；「次長相同前綴後綴」便可顧名思義。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e字串\u003c/th\u003e\n\u003cth\u003e相同前綴後綴\u003c/th\u003e\n\u003cth\u003e次長相同前綴後綴\u003c/th\u003e\n\u003cth\u003eF函數\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eABCDE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e∅\u003c/code\u003e、\u003ccode\u003eABCDE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e∅\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eABCDA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e∅\u003c/code\u003e、\u003ccode\u003eA\u003c/code\u003e、\u003ccode\u003eABCDA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eABCAB\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e∅\u003c/code\u003e、\u003ccode\u003eAB\u003c/code\u003e、\u003ccode\u003eABCAB\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAB\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eABCBA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e∅\u003c/code\u003e、\u003ccode\u003eA\u003c/code\u003e、\u003ccode\u003eABCBA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eAAAAA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e∅\u003c/code\u003e、\u003ccode\u003eA\u003c/code\u003e、\u003ccode\u003eAA\u003c/code\u003e、\u003ccode\u003eAAA\u003c/code\u003e、\u003ccode\u003eAAAA\u003c/code\u003e、\u003ccode\u003eAAAAA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAAAA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"部分匹配表\"\u003e部分匹配表\u003c/h3\u003e\n\u003cp\u003e我們為\u003ccode\u003eP\u003c/code\u003e建立\u003cstrong\u003e部分匹配表\u003c/strong\u003e（Partial match table）來決定比對失敗時所要挪動的幅度。在此以\u003ccode\u003eP = \u0026quot;ABCDABD\u0026quot;\u003c/code\u003e為例。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ccode\u003ej\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eP[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eC\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e當\u003ccode\u003eP[0]\u003c/code\u003e比對失敗後，必須將\u003ccode\u003eP\u003c/code\u003e右移才能繼續比對，因此設\u003ccode\u003enext[j] = -1\u003c/code\u003e。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ccode\u003ej\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eP[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eC\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e在\u003ccode\u003ej \u0026gt; 0\u003c/code\u003e的情況下，\u003ccode\u003enext[j] = F(P[0 ... j])\u003c/code\u003e。例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enext[1]\u003c/code\u003e = \u003ccode\u003eF(P[0 ... 1])\u003c/code\u003e = \u003ccode\u003eF(\u0026quot;A\u0026quot;)\u003c/code\u003e = \u003ccode\u003elen(\u0026quot;\u0026quot;)\u003c/code\u003e = 0\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext[5]\u003c/code\u003e = \u003ccode\u003eF(P[0 ... 5])\u003c/code\u003e = \u003ccode\u003eF(\u0026quot;ABCDA\u0026quot;)\u003c/code\u003e = \u003ccode\u003elen(\u0026quot;A\u0026quot;)\u003c/code\u003e = 1\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext[6]\u003c/code\u003e = \u003ccode\u003eF(P[0 ... 6])\u003c/code\u003e = \u003ccode\u003eF(\u0026quot;ABCDAB\u0026quot;)\u003c/code\u003e = \u003ccode\u003elen(\u0026quot;AB\u0026quot;)\u003c/code\u003e = 2\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ccode\u003ej\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eP[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eC\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e其原理便是：當比對失敗時，部分匹配表使你可以直接從\u003ccode\u003enext[j]\u003c/code\u003e開始繼續搜尋而避免「\u003cstrong\u003e挪動、比對、失敗\u003c/strong\u003e」循環（暴力法第二到四步），便達成減少挪動字數的目的。\u003c/p\u003e\n\u003cp\u003e接著便利用\u003ccode\u003enext[j]\u003c/code\u003e來搜尋字串：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若\u003ccode\u003eT[i] == P[j]\u003c/code\u003e，則\u003ccode\u003ei++\u003c/code\u003e、\u003ccode\u003ej++\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e若\u003ccode\u003eT[i] != P[j]\u003c/code\u003e，則\u003ccode\u003ej = next[j]\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e若\u003ccode\u003ej == -1\u003c/code\u003e，則\u003ccode\u003ei++\u003c/code\u003e、\u003ccode\u003ej++\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e時間複雜度\u003cstrong\u003eO(m+n)\u003c/strong\u003e，空間複雜度\u003cstrong\u003eO(n)\u003c/strong\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003eT = ABCDAABCDABD\nP = ABCDABD\n----------------\n1.\nT = ABCDAABCDABD\nP = ABCDABD\n    ^^^^^X\n\n2.\nT = ABCDAABCDABD\nP =     ABCDABD\n         X\n\n3.\nT = ABCDAABCDABD\nP =      ABCDABD\n         ^^^^^^#\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e此演算法衍生的另一個優點便是，不用每次都從\u003ccode\u003eP[0]\u003c/code\u003e開始比較，因為F函數已經保證移動後「次長相同前綴後綴」的前綴部分和\u003ccode\u003eT\u003c/code\u003e的部分相同，如上方的步驟二。\u003c/p\u003e\n\u003cp\u003e有文獻稱這種演算法為MP演算法（Morris–Pratt algorithm）。\u003c/p\u003e\n\u003ch2 id=\"kmp演算法\"\u003eKMP演算法\u003c/h2\u003e\n\u003cp\u003e觀察上面的演算法，在第一步遇到不匹配的字元\u003ccode\u003eP\u003c/code\u003e便右移，第二步時\u003ccode\u003eP[1]\u003c/code\u003e又不等於\u003ccode\u003eT[5]\u003c/code\u003e，須再右移一次。為了使演算法更優化，這時便要藉由\u003cstrong\u003e優化\u003c/strong\u003e\u003ccode\u003enext\u003c/code\u003e來\u003cstrong\u003e避免連續挪移\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e再以\u003ccode\u003eP = \u0026quot;ABCDABD\u0026quot;\u003c/code\u003e為例並找出連續挪移的條件。\u003ccode\u003eP[0 ... 5] = \u0026quot;ABCDA\u0026quot;\u003c/code\u003e的「次長相同前綴後綴」為\u003ccode\u003eP[0 ... 1] = P[4 ... 5] = \u0026quot;A\u0026quot;\u003c/code\u003e，若\u003ccode\u003eP[0 .. 1]\u003c/code\u003e和\u003ccode\u003eP[4 ... 5]\u003c/code\u003e的\u003cstrong\u003e下一個字元\u003c/strong\u003e相同（都是\u003ccode\u003e'B'\u003c/code\u003e），則第一次移動後所比較的字元也會相同（\u003ccode\u003e'A' != 'B'\u003c/code\u003e），因此\u003ccode\u003eP\u003c/code\u003e必須再移動一次。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003eP          = ABCDABD\nP[0 ... 5] = ABCDA\n             !*  !*\n--------------------\n\u0026#39;!\u0026#39; =\u0026gt; 次長相同前綴後綴\n\u0026#39;*\u0026#39; =\u0026gt; 次長相同前綴後綴的下一個字元\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003enewNext\u003c/code\u003e為\u003ccode\u003enext\u003c/code\u003e的優化版，以實現「避免連續挪移」。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ccode\u003ej\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eP[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eC\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enewNext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e定義\u003ccode\u003enewNext[0] = -1\u003c/code\u003e，原因見上一節。若\u003ccode\u003eP[0 ... j]\u003c/code\u003e的「次長相同前綴後綴」的前綴和後綴沒有相同的「下一個字元」，則\u003ccode\u003enewNext[j] = next[j]\u003c/code\u003e。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ccode\u003ej\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eP[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eC\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enewNext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e若有相同的下一個字元，則藉遞迴法使其移動時一次到位，即\u003ccode\u003enewNext[j] = newNext[next[j]]\u003c/code\u003e。在本例中：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ccode\u003ej\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eP[0 ... j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eABCD\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eABCDA\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e次長相同前綴後綴的\u003cstrong\u003e前綴\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eP[0 ... 0]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eP[0 ... 1]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e次長相同前綴後綴的\u003cstrong\u003e後綴\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eP[4 ... 4]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eP[4 ... 5]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e相同的\u003cstrong\u003e下一個字元\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eB\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enewNext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e註：\u003ccode\u003eP[0 ... 4]\u003c/code\u003e的次長前綴後綴為空，但其仍有相同的下一個字元。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e將\u003ccode\u003enewNext[j]\u003c/code\u003e填完：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ccode\u003ej\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e2\u003c/th\u003e\n\u003cth\u003e3\u003c/th\u003e\n\u003cth\u003e4\u003c/th\u003e\n\u003cth\u003e5\u003c/th\u003e\n\u003cth\u003e6\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eP[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eC\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003ctd\u003eA\u003c/td\u003e\n\u003ctd\u003eB\u003c/td\u003e\n\u003ctd\u003eD\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enewNext[j]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e接著便利用\u003ccode\u003enewNext[j]\u003c/code\u003e來搜尋字串，規則同上方的改良版：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若\u003ccode\u003eT[i] == P[j]\u003c/code\u003e，則\u003ccode\u003ei++\u003c/code\u003e、\u003ccode\u003ej++\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e若\u003ccode\u003eT[i] != P[j]\u003c/code\u003e，則\u003ccode\u003ej = newNext[j]\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e若\u003ccode\u003ej == -1\u003c/code\u003e，則\u003ccode\u003ei++\u003c/code\u003e、\u003ccode\u003ej++\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e時間複雜度\u003cstrong\u003eO(m+n)\u003c/strong\u003e，空間複雜度\u003cstrong\u003eO(n)\u003c/strong\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003eT = ABCDAABCDABD\nP = ABCDABD\n----------------\n1.\nT = ABCDAABCDABD\nP = ABCDABD\n    ^^^^^X\n\n2.\nT = ABCDAABCDABD\nP =      ABCDABD\n         ^^^^^^#\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"參考資料\"\u003e參考資料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\"\u003eKnuth–Morris–Pratt algorithm - Wikipedia\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://web.ntnu.edu.tw/~algo/StringSearching.html\"\u003e演算法筆記 - String Searching\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.evanlin.com/about-kmp/\"\u003e[TIL] 有關字串搜尋的演算法_ KMP\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/\"\u003eKMP Algorithm for Pattern Searching - GeeksforGeeks\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"}</script><link rel=preload as=script href="/bundle.js?v=1601818820"></head><body><header id=nav class=header><div class="ax-l-i max-w-6xl"><div class=ax-logo><a class=block href=/ title=L筆記><span class="font-semibold text-raven-900">L筆記</span></a></div><div class=ax-user><a class="p-2 w-8 h-8 block text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" target=_blank rel="noopener nofollow" href="https://www.google.com/search?q=site:https://2020leon.github.io/"><svg class="fill-current" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.67 12.804c0-5.6 4.544-10.134 10.133-10.134s10.134 4.544 10.134 10.134-4.544 10.133-10.134 10.133S2.67 18.393 2.67 12.804zm28.943 16.923-8.868-8.868c4.287-5.3 3.68-13.012-1.378-17.57S8.564-1.066 3.75 3.75s-5.017 12.558-.46 17.618 12.28 5.665 17.57 1.378l8.868 8.868a1.33 1.33.0 002.231-.597c.123-.46-.008-.952-.345-1.29h0z"/></svg></a><a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href=/posts/>文章</a></div></div></header><main><div class=default-single><div class="ax-title ax-l-o"><div class="ax-l-i max-w-title-with-toc-below"><h1 class="post-title font-content-title font-normal leading-tight tracking-default text-40">[演算法] KMP演算法簡介</h1><p class="post-subtitle font-content-sans font-light text-xl text-raven-500 mt-3">優化的字串搜尋演算法</p><div class="ax-meta flex items-center mt-5"><div class="flex-grow min-w-0"><div class="flex items-center"><div class=flex-shrink-0><img class="w-12 h-12 sm:w-14 sm:h-14 object-cover p-3px rounded-full border border-blue-300" src=/images/profile/profile.svg alt="Leon Chang"></div><div class="flex-shrink-0 ml-2 leading-tight font-content-sans"><a class="block text-sm text-raven-800 hover:text-raven-900 hover:underline focus:underline" target=_blank rel="noopener nofollow" title="Leon Chang" href=https://2020leon.github.io/>Leon Chang</a>
<time class="text-sm text-raven-500" datetime=2020-10-04T13:34:38Z>2020-10-04</time></div></div></div><div><div class="flex items-center"><a class="flex-shrink-0 block text-raven-800 hover:text-raven-900" target=_blank rel="noopener nofollow" href="https://twitter.com/intent/tweet?text=%5b%e6%bc%94%e7%ae%97%e6%b3%95%5d%20KMP%e6%bc%94%e7%ae%97%e6%b3%95%e7%b0%a1%e4%bb%8b%20by%20%40%25%21s%28%3cnil%3e%29%20https%3a%2f%2f2020leon.github.io%2fposts%2falgorithm-kmp%2f"><svg class="w-6 h-6 fill-current" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11.0 01-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56.0 00-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57.0 002.914 5.452 6.48 6.48.0 01-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42.0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18.0 01-8.134 2.798c-.538.0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072.0 18.672-10 18.672-18.668.0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg></a><a class="ml-3 flex-shrink-0 block text-raven-800 hover:text-raven-900" target=_blank rel="noopener nofollow" href="https://www.facebook.com/dialog/share?app_id=&display=page&href=https%3a%2f%2f2020leon.github.io%2fposts%2falgorithm-kmp%2f"><svg class="w-6 h-6 fill-current" viewBox="-7 -3.5 39 39" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M30.234.0H1.765C.8.001.0.79.0 1.766v28.47C.001 31.2.79 32 1.766 32h15.328V19.625h-4.156V14.78h4.156v-3.564c0-4.134 2.523-6.384 6.21-6.384 1.766.0 3.284.13 3.726.2v4.32h-2.543c-2.006.0-2.394.953-2.394 2.352v3.085h4.797l-.625 4.844h-4.172V32h8.14C31.21 32 32 31.2 32 30.234V1.765C32 .8 31.21.0 30.234.0z"/></svg></a></div></div></div></div></div><div class="ax-content ax-l-o"><div class="ax-l-i max-w-680"><article class=cdata><p>字串搜尋經常出現在日常生活中，因此優化後的字串搜尋演算法必然是大家所追求的目標，而<strong>KMP演算法</strong>（Knuth–Morris–Pratt algorithm）便是其中之一。在此整理網路上關於KMP的資料。</p><h2 id=符號定義>符號定義</h2><p>字串搜尋便是在<strong>文字材料</strong>（text）中找到一些<strong>字詞</strong>（pattern）。因此定義<code>T</code>代表要搜索的文章（字串），<code>P</code>則代表使用者要找的字詞。</p><p>本文的所有字串都是由零開始的陣列。若<code>P = "ALGORITHM"</code>，則<code>P[1]</code>是<code>L</code>。<code>i</code>和<code>j</code>分別代表<code>T</code>和<code>P</code>的索引。</p><p><code>P[0 ... j]</code>表示包含<code>0</code>但不包含<code>j</code>的字元，在數學上用區間表示即是<code>[0,j)</code>。若<code>P = "ALGORITHM"</code>，則<code>P[2 ... 5] = "GOR"</code>。</p><h2 id=暴力法>暴力法</h2><p><code>T</code>和<code>P</code>頭對頭（<code>i = 0</code>、<code>j = 0</code>），一次取一字一一比對。</p><ul><li>若<code>T[i] == P[j]</code>，則<code>i++</code>、<code>j++</code></li><li>若<code>T[i] != P[j]</code>，則<code>i = i - j + 1</code>、<code>j = 0</code></li></ul><p>時間複雜度<strong>O(mn)</strong>，空間複雜度<strong>O(1)</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>T = ABCDAABCDABD
P = ABCDABD
----------------
1.
T = ABCDAABCDABD
P = ABCDABD
    ^^^^^X

2.
T = ABCDAABCDABD
P =  ABCDABD
     X

3.
T = ABCDAABCDABD
P =   ABCDABD
      X

4.
T = ABCDAABCDABD
P =    ABCDABD
       X

5.
T = ABCDAABCDABD
P =     ABCDABD
        ^X

6.
T = ABCDAABCDABD
P =      ABCDABD
         ^^^^^^#
</code></pre></div><h2 id=改良>改良</h2><p>暴力法的精神便是逐一比對，但事實上不必如此。觀察上方第二至五步，若能一次性將<code>P</code>移動至第五步的位置便能<strong>減少挪動次數</strong>而增加比對效率，尤其<code>T</code>為長字串時效果更為顯著。</p><p>第一步比對失敗時，<code>j = 5</code>。我們發現，可以藉由預先分析<code>P[0 ... 5] = "ABCDA"</code>（從<code>P[0]</code>到第一步比對失敗<strong>前</strong>的子字串）來決定<code>P</code>要挪動多少。</p><p>接下來介紹實現此想法所需的前置作業。</p><h3 id=failure-function>Failure Function</h3><p>中文簡稱<strong>F函數</strong>，又稱<strong>prefix function</strong>、<strong>border function</strong>。給定一字串，它便會輸出「<strong>次長相同前綴後綴</strong>（longest proper prefix-suffix）」的長度。一個字串可能有不只一個「相同前綴後綴（prefix-suffix）」，而「最長相同前綴後綴」肯定是字串本身；「次長相同前綴後綴」便可顧名思義。</p><table><thead><tr><th>字串</th><th>相同前綴後綴</th><th>次長相同前綴後綴</th><th>F函數</th></tr></thead><tbody><tr><td><code>ABCDE</code></td><td><code>∅</code>、<code>ABCDE</code></td><td><code>∅</code></td><td>0</td></tr><tr><td><code>ABCDA</code></td><td><code>∅</code>、<code>A</code>、<code>ABCDA</code></td><td><code>A</code></td><td>1</td></tr><tr><td><code>ABCAB</code></td><td><code>∅</code>、<code>AB</code>、<code>ABCAB</code></td><td><code>AB</code></td><td>2</td></tr><tr><td><code>ABCBA</code></td><td><code>∅</code>、<code>A</code>、<code>ABCBA</code></td><td><code>A</code></td><td>1</td></tr><tr><td><code>AAAAA</code></td><td><code>∅</code>、<code>A</code>、<code>AA</code>、<code>AAA</code>、<code>AAAA</code>、<code>AAAAA</code></td><td><code>AAAA</code></td><td>4</td></tr></tbody></table><h3 id=部分匹配表>部分匹配表</h3><p>我們為<code>P</code>建立<strong>部分匹配表</strong>（Partial match table）來決定比對失敗時所要挪動的幅度。在此以<code>P = "ABCDABD"</code>為例。</p><table><thead><tr><th><code>j</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><code>P[j]</code></td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td><code>next[j]</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>當<code>P[0]</code>比對失敗後，必須將<code>P</code>右移才能繼續比對，因此設<code>next[j] = -1</code>。</p><table><thead><tr><th><code>j</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><code>P[j]</code></td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td><code>next[j]</code></td><td>-1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>在<code>j > 0</code>的情況下，<code>next[j] = F(P[0 ... j])</code>。例如：</p><ul><li><code>next[1]</code> = <code>F(P[0 ... 1])</code> = <code>F("A")</code> = <code>len("")</code> = 0</li><li><code>next[5]</code> = <code>F(P[0 ... 5])</code> = <code>F("ABCDA")</code> = <code>len("A")</code> = 1</li><li><code>next[6]</code> = <code>F(P[0 ... 6])</code> = <code>F("ABCDAB")</code> = <code>len("AB")</code> = 2</li></ul><table><thead><tr><th><code>j</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><code>P[j]</code></td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td><code>next[j]</code></td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>其原理便是：當比對失敗時，部分匹配表使你可以直接從<code>next[j]</code>開始繼續搜尋而避免「<strong>挪動、比對、失敗</strong>」循環（暴力法第二到四步），便達成減少挪動字數的目的。</p><p>接著便利用<code>next[j]</code>來搜尋字串：</p><ul><li>若<code>T[i] == P[j]</code>，則<code>i++</code>、<code>j++</code></li><li>若<code>T[i] != P[j]</code>，則<code>j = next[j]</code><ul><li>若<code>j == -1</code>，則<code>i++</code>、<code>j++</code></li></ul></li></ul><p>時間複雜度<strong>O(m+n)</strong>，空間複雜度<strong>O(n)</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>T = ABCDAABCDABD
P = ABCDABD
----------------
1.
T = ABCDAABCDABD
P = ABCDABD
    ^^^^^X

2.
T = ABCDAABCDABD
P =     ABCDABD
         X

3.
T = ABCDAABCDABD
P =      ABCDABD
         ^^^^^^#
</code></pre></div><p>此演算法衍生的另一個優點便是，不用每次都從<code>P[0]</code>開始比較，因為F函數已經保證移動後「次長相同前綴後綴」的前綴部分和<code>T</code>的部分相同，如上方的步驟二。</p><p>有文獻稱這種演算法為MP演算法（Morris–Pratt algorithm）。</p><h2 id=kmp演算法>KMP演算法</h2><p>觀察上面的演算法，在第一步遇到不匹配的字元<code>P</code>便右移，第二步時<code>P[1]</code>又不等於<code>T[5]</code>，須再右移一次。為了使演算法更優化，這時便要藉由<strong>優化</strong><code>next</code>來<strong>避免連續挪移</strong>。</p><p>再以<code>P = "ABCDABD"</code>為例並找出連續挪移的條件。<code>P[0 ... 5] = "ABCDA"</code>的「次長相同前綴後綴」為<code>P[0 ... 1] = P[4 ... 5] = "A"</code>，若<code>P[0 .. 1]</code>和<code>P[4 ... 5]</code>的<strong>下一個字元</strong>相同（都是<code>'B'</code>），則第一次移動後所比較的字元也會相同（<code>'A' != 'B'</code>），因此<code>P</code>必須再移動一次。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>P          = ABCDABD
P[0 ... 5] = ABCDA
             !*  !*
--------------------
&#39;!&#39; =&gt; 次長相同前綴後綴
&#39;*&#39; =&gt; 次長相同前綴後綴的下一個字元
</code></pre></div><p><code>newNext</code>為<code>next</code>的優化版，以實現「避免連續挪移」。</p><table><thead><tr><th><code>j</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><code>P[j]</code></td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td><code>next[j]</code></td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr><tr><td><code>newNext[j]</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>定義<code>newNext[0] = -1</code>，原因見上一節。若<code>P[0 ... j]</code>的「次長相同前綴後綴」的前綴和後綴沒有相同的「下一個字元」，則<code>newNext[j] = next[j]</code>。</p><table><thead><tr><th><code>j</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><code>P[j]</code></td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td><code>next[j]</code></td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr><tr><td><code>newNext[j]</code></td><td>-1</td><td>0</td><td>0</td><td>0</td><td></td><td></td><td>2</td></tr></tbody></table><p>若有相同的下一個字元，則藉遞迴法使其移動時一次到位，即<code>newNext[j] = newNext[next[j]]</code>。在本例中：</p><table><thead><tr><th><code>j</code></th><th>4</th><th>5</th></tr></thead><tbody><tr><td><code>P[0 ... j]</code></td><td><code>ABCD</code></td><td><code>ABCDA</code></td></tr><tr><td>次長相同前綴後綴的<strong>前綴</strong></td><td><code>P[0 ... 0]</code></td><td><code>P[0 ... 1]</code></td></tr><tr><td>次長相同前綴後綴的<strong>後綴</strong></td><td><code>P[4 ... 4]</code></td><td><code>P[4 ... 5]</code></td></tr><tr><td>相同的<strong>下一個字元</strong></td><td><code>A</code></td><td><code>B</code></td></tr><tr><td><code>newNext[j]</code></td><td>-1</td><td>0</td></tr></tbody></table><blockquote><p>註：<code>P[0 ... 4]</code>的次長前綴後綴為空，但其仍有相同的下一個字元。</p></blockquote><p>將<code>newNext[j]</code>填完：</p><table><thead><tr><th><code>j</code></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><code>P[j]</code></td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td><code>next[j]</code></td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr><tr><td><code>newNext[j]</code></td><td>-1</td><td>0</td><td>0</td><td>0</td><td>-1</td><td>0</td><td>2</td></tr></tbody></table><p>接著便利用<code>newNext[j]</code>來搜尋字串，規則同上方的改良版：</p><ul><li>若<code>T[i] == P[j]</code>，則<code>i++</code>、<code>j++</code></li><li>若<code>T[i] != P[j]</code>，則<code>j = newNext[j]</code><ul><li>若<code>j == -1</code>，則<code>i++</code>、<code>j++</code></li></ul></li></ul><p>時間複雜度<strong>O(m+n)</strong>，空間複雜度<strong>O(n)</strong>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>T = ABCDAABCDABD
P = ABCDABD
----------------
1.
T = ABCDAABCDABD
P = ABCDABD
    ^^^^^X

2.
T = ABCDAABCDABD
P =      ABCDABD
         ^^^^^^#
</code></pre></div><h2 id=參考資料>參考資料</h2><ul><li><a href=https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm>Knuth–Morris–Pratt algorithm - Wikipedia</a></li><li><a href=http://web.ntnu.edu.tw/~algo/StringSearching.html>演算法筆記 - String Searching</a></li><li><a href=https://www.evanlin.com/about-kmp/>[TIL] 有關字串搜尋的演算法_ KMP</a></li><li><a href=https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/>KMP Algorithm for Pattern Searching - GeeksforGeeks</a></li></ul><blockquote><ul><li>作者：Leon Chang</li><li>網址：<a href=https://2020leon.github.io/posts/algorithm-kmp/>https://2020leon.github.io/posts/algorithm-kmp/</a></li><li>版權聲明：本著作係採用<a rel=license href=http://creativecommons.org/licenses/by-sa/3.0/tw/>創用 CC 姓名標示-相同方式分享 3.0 臺灣 授權條款</a>授權</li></ul></blockquote><div class="flex flex-wrap"><div class="font-content-sans font-semibold text-raven-700 py-2 px-4 m-2">分類：</div><a class="rounded font-content-sans font-semibold text-raven-700 bg-raven-100 hover:bg-raven-200 py-2 px-4 m-2" href=https://2020leon.github.io/categories/algorithm/>Algorithm</a><div class="font-content-sans font-semibold text-raven-700 py-2 px-4 m-2">標籤：</div><a class="rounded font-content-sans font-semibold text-raven-700 bg-raven-100 hover:bg-raven-200 py-2 px-4 m-2" href=https://2020leon.github.io/tags/algorithm/>#algorithm</a>
<a class="rounded font-content-sans font-semibold text-raven-700 bg-raven-100 hover:bg-raven-200 py-2 px-4 m-2" href=https://2020leon.github.io/tags/string/>#string</a></div></article></div><aside class="hidden toc"><nav id=TableOfContents><ul><li><a href=#符號定義>符號定義</a></li><li><a href=#暴力法>暴力法</a></li><li><a href=#改良>改良</a><ul><li><a href=#failure-function>Failure Function</a></li><li><a href=#部分匹配表>部分匹配表</a></li></ul></li><li><a href=#kmp演算法>KMP演算法</a></li><li><a href=#參考資料>參考資料</a></li></ul></nav></aside></div></div></main><footer class=footer><div class="ax-l-i max-w-6xl"><nav class="flex items-center justify-center"><a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href=/>首頁</a>
<a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href=/posts/>文章</a></nav><div class="footer-social flex items-center justify-center mt-4"><a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target=_blank rel="noopener nofollow" href=https://github.com/2020leon><svg class="fill-current" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M15.998.0C7.164.0.0 7.35.0 16.417.0 23.67 4.584 29.82 10.944 31.994c.8.15 1.092-.356 1.092-.79l-.022-2.792c-4.45.99-5.4-2.202-5.4-2.202-.726-1.896-1.776-2.4-1.776-2.4-1.454-1.018.108-.998.108-.998 1.606.117 2.45 1.693 2.45 1.693 1.428 2.507 3.746 1.784 4.658 1.363.144-1.06.558-1.784 1.016-2.195-3.552-.415-7.288-1.823-7.288-8.113.0-1.792.624-3.258 1.648-4.406-.166-.415-.714-2.085.156-4.344.0.0 1.344-.44 4.4 1.683 1.276-.364 2.644-.546 4.006-.552a14.98 14.98.0 014.006.554C23.062 6.37 24.404 6.8 24.404 6.8c.872 2.26.324 3.93.16 4.344 1.026 1.148 1.644 2.614 1.644 4.406.0 6.306-3.74 7.694-7.304 8.1.574.507 1.086 1.51 1.086 3.04l-.02 4.503c0 .44.288.95 1.1.788C27.42 29.817 32 23.667 32 16.417 32 7.35 24.836.0 15.998.0z"/></svg></a></div><div class="footer-copyright text-sm text-center text-gray-500 mt-4">&#169; 2020-2020 L筆記</div><div class="text-sm sm:text-xs text-center text-gray-500 mt-2"><a href="https://www.axiomtheme.com/?utm_source=theme-footer&utm_medium=website&utm_campaign=referral"></a></div></div></footer><script src="/bundle.js?v=1601818820"></script></body></html>