[{"categories":["virtualbox"],"content":"VirtualBox當Guest OS是Windows 10時解析度預設只提供4:3可以選擇。在此紀錄如何自訂解析度。\n找到VBoxManage執行檔 VBoxManage的路徑在不同的Host OS中不盡相同。\nWindows 若在安裝VirtualBox時沒有特別設定，VBoxManage.exe會在C:\\Program Files\\Oracle\\VirtualBox裡。切換至該資料夾以利稍後的操作。\ncd C:\\Program Files\\Oracle\\VirtualBox Linux/MacOS 在安裝VirtualBox時會直接在$PATH下安裝執行檔。\n解除解析度限制 1  VBoxManage setextradata \"YourMachineName\" GUI/MaxGuestResolution any   將\"YourMachineName\"改成虛擬機的名稱，或是改成global（不需引號）解除所有虛擬機的解析度限制。\n設定解析度 1  VBoxManage setextradata \"YourMachineName\" CustomVideoMode1 \"WidthxHeightxBpp\"   將\"WidthxHeightxBpp\"改成解析度，例如：\n1  VBoxManage setextradata \"Windows 10\" CustomVideoMode1 \"1440x900x32\"   bpp為位元每像素（bits per pixel），不知道是什麼的可以參考這篇，大部分的電腦通常是32bbp。\n接著再度打開虛擬機，至顯示設定，就可以設定成方才所設定的解析度了。\n雖然本篇名為「Windows 10解析度」，但若其他Guest OS遇到無法設定解析度時亦可試試本篇的方法。\n參考資料  How to run a virtual machine in VirtualBox with a custom resolution (3840x2160) | Our Code World  ","description":"","subtitle":"解決虛擬機解析度問題","title":"[VirtualBox] 自訂Windows 10解析度","uri":"/posts/virtualbox-custom-resolution/"},{"categories":["algorithm"],"content":"字串搜尋經常出現在日常生活中，因此優化後的字串搜尋演算法必然是大家所追求的目標，而KMP演算法（Knuth–Morris–Pratt algorithm）便是其中之一。在此整理網路上關於KMP的資料。\n符號定義 字串搜尋便是在文字材料（text）中找到一些字詞（pattern）。因此定義T代表要搜索的文章（字串），P則代表使用者要找的字詞。\n本文的所有字串都是由零開始的陣列。若P = \"ALGORITHM\"，則P[1]是L。i和j分別代表T和P的索引。\nP[0 ... j]表示包含0但不包含j的字元，在數學上用區間表示即是[0,j)。若P = \"ALGORITHM\"，則P[2 ... 5] = \"GOR\"。\n暴力法 T和P頭對頭（i = 0、j = 0），一次取一字一一比對。\n 若T[i] == P[j]，則i++、j++ 若T[i] != P[j]，則i = i - j + 1、j = 0  時間複雜度O(mn)，空間複雜度O(1)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  T = ABCDAABCDABD P = ABCDABD ---------------- 1. T = ABCDAABCDABD P = ABCDABD ^^^^^X 2. T = ABCDAABCDABD P = ABCDABD X 3. T = ABCDAABCDABD P = ABCDABD X 4. T = ABCDAABCDABD P = ABCDABD X 5. T = ABCDAABCDABD P = ABCDABD ^X 6. T = ABCDAABCDABD P = ABCDABD ^^^^^^#   改良 暴力法的精神便是逐一比對，但事實上不必如此。觀察上方第二至五步，若能一次性將P移動至第五步的位置便能減少挪動次數而增加比對效率，尤其T為長字串時效果更為顯著。\n第一步比對失敗時，j = 5。我們發現，可以藉由預先分析P[0 ... 5] = \"ABCDA\"（從P[0]到第一步比對失敗前的子字串）來決定P要挪動多少。\n接下來介紹實現此想法所需的前置作業。\nFailure Function 中文簡稱F函數，又稱prefix function、border function。給定一字串，它便會輸出「次長相同前綴後綴（longest proper prefix-suffix）」的長度。一個字串可能有不只一個「相同前綴後綴（prefix-suffix）」，而「最長相同前綴後綴」肯定是字串本身；「次長相同前綴後綴」便可顧名思義。\n   字串 相同前綴後綴 次長相同前綴後綴 F函數     ABCDE ∅、ABCDE ∅ 0   ABCDA ∅、A、ABCDA A 1   ABCAB ∅、AB、ABCAB AB 2   ABCBA ∅、A、ABCBA A 1   AAAAA ∅、A、AA、AAA、AAAA、AAAAA AAAA 4    部分匹配表 我們為P建立部分匹配表（Partial match table）來決定比對失敗時所要挪動的幅度。在此以P = \"ABCDABD\"為例。\n   j 0 1 2 3 4 5 6     P[j] A B C D A B D   next[j]           當P[0]比對失敗後，必須將P右移才能繼續比對，因此設next[j] = -1。\n   j 0 1 2 3 4 5 6     P[j] A B C D A B D   next[j] -1          在j \u003e 0的情況下，next[j] = F(P[0 ... j])。例如：\n next[1] = F(P[0 ... 1]) = F(\"A\") = len(\"\") = 0 next[5] = F(P[0 ... 5]) = F(\"ABCDA\") = len(\"A\") = 1 next[6] = F(P[0 ... 6]) = F(\"ABCDAB\") = len(\"AB\") = 2     j 0 1 2 3 4 5 6     P[j] A B C D A B D   next[j] -1 0 0 0 0 1 2    其原理便是：當比對失敗時，部分匹配表使你可以直接從next[j]開始繼續搜尋而避免「挪動、比對、失敗」循環（暴力法第二到四步），便達成減少挪動字數的目的。\n接著便利用next[j]來搜尋字串：\n 若T[i] == P[j]，則i++、j++ 若T[i] != P[j]，則j = next[j]  若j == -1，則i++、j++    時間複雜度O(m+n)，空間複雜度O(n)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  T = ABCDAABCDABD P = ABCDABD ---------------- 1. T = ABCDAABCDABD P = ABCDABD ^^^^^X 2. T = ABCDAABCDABD P = ABCDABD X 3. T = ABCDAABCDABD P = ABCDABD ^^^^^^#   此演算法衍生的另一個優點便是，不用每次都從P[0]開始比較，因為F函數已經保證移動後「次長相同前綴後綴」的前綴部分和T的部分相同，如上方的步驟二。\n有文獻稱這種演算法為MP演算法（Morris–Pratt algorithm）。\nKMP演算法 觀察上面的演算法，在第一步遇到不匹配的字元P便右移，第二步時P[1]又不等於T[5]，須再右移一次。為了使演算法更優化，這時便要藉由優化next來避免連續挪移。\n再以P = \"ABCDABD\"為例並找出連續挪移的條件。P[0 ... 5] = \"ABCDA\"的「次長相同前綴後綴」為P[0 ... 1] = P[4 ... 5] = \"A\"，若P[0 .. 1]和P[4 ... 5]的下一個字元相同（都是'B'），則第一次移動後所比較的字元也會相同（'A' != 'B'），因此P必須再移動一次。\n1 2 3 4 5 6  P = ABCDABD P[0 ... 5] = ABCDA !* !* -------------------- '!' =\u003e 次長相同前綴後綴 '*' =\u003e 次長相同前綴後綴的下一個字元   newNext為next的優化版，以實現「避免連續挪移」。\n   j 0 1 2 3 4 5 6     P[j] A B C D A B D   next[j] -1 0 0 0 0 1 2   newNext[j]           定義newNext[0] = -1，原因見上一節。若P[0 ... j]的「次長相同前綴後綴」的前綴和後綴沒有相同的「下一個字元」，則newNext[j] = next[j]。\n   j 0 1 2 3 4 5 6     P[j] A B C D A B D   next[j] -1 0 0 0 0 1 2   newNext[j] -1 0 0 0   2    若有相同的下一個字元，則藉遞迴法使其移動時一次到位，即newNext[j] = newNext[next[j]]。在本例中：\n   j 4 5     P[0 ... j] ABCD ABCDA   次長相同前綴後綴的前綴 P[0 ... 0] P[0 ... 1]   次長相同前綴後綴的後綴 P[4 ... 4] P[4 ... 5]   相同的下一個字元 A B   newNext[j] -1 0     註：P[0 ... 4]的次長前綴後綴為空，但其仍有相同的下一個字元。\n 將newNext[j]填完：\n   j 0 1 2 3 4 5 6     P[j] A B C D A B D   next[j] -1 0 0 0 0 1 2   newNext[j] -1 0 0 0 -1 0 2    接著便利用newNext[j]來搜尋字串，規則同上方的改良版：\n 若T[i] == P[j]，則i++、j++ 若T[i] != P[j]，則j = newNext[j]  若j == -1，則i++、j++    時間複雜度O(m+n)，空間複雜度O(n)。\n1 2 3 4 5 6 7 8 9 10 11 12  T = ABCDAABCDABD P = ABCDABD ---------------- 1. T = ABCDAABCDABD P = ABCDABD ^^^^^X 2. T = ABCDAABCDABD P = ABCDABD ^^^^^^#   參考資料  Knuth–Morris–Pratt algorithm - Wikipedia 演算法筆記 - String Searching [TIL] 有關字串搜尋的演算法_ KMP KMP Algorithm for Pattern Searching - GeeksforGeeks  ","description":"","subtitle":"優化的字串搜尋演算法","title":"[演算法] KMP演算法簡介","uri":"/posts/algorithm-kmp/"},{"categories":["transportation"],"content":"\n自從臺北捷運環狀線西環段於2020年1月31日通車後，新店和板橋之間的交通多了一項新選擇。從新店到板橋要怎麼搭最省時或省錢？直接實測！\n測試方法 起終點  起點：捷運新店區公所站（北新）（公車站） 終點：板橋車站地下一樓臺鐵入口  路線  捷運新店線、板南線 捷運新店線、環狀線 930公車  捷運新店線、板南線  測試日期：2020年8月13日     地點 時間     起點 17:26   捷運新店區公所站 17:29   捷運西門站 17:47   捷運板南線板橋站 18:01   終點 18:05    費時39分鐘。基本上從新店區公所到西門都有位子坐，而西門到板橋通常沒位子坐。尖峰時段在西門轉車，運氣差的話要等兩班捷運才有空間可以擠上車。\n捷運新店線、環狀線  測試日期：2020年8月20日     地點 時間     起點 17:27   捷運新店區公所站 17:29   捷運新店線大坪林站 17:37   捷運環狀線大坪林站 17:40   捷運環狀線板橋站 18:02   終點 18:08    費時41分鐘。環狀線的搭乘人數比其他高運量路線相比略少，通常有位子坐。整個環狀線的乘車體驗就是煞煞停停，大概是為避免過彎時車速過快及保持車距等。\n而從捷運環狀線板橋站到臺鐵板橋站據所知至少有兩條路可以走。一是從5號出口走地下道到車站本體，二是從4號出口走行人穿越道到車站本體。本次測試是經地下道到車站本體。\n930公車 \n 測試日期：2020年8月14日     地點 時間     起點 17:26   板橋車站（文化路） 18:17   板橋車站站體 18:21   終點 18:23    費時57分鐘。當天是星期五，下午又有午後雷陣雨，無論是在大坪林、臺64線或是板橋市區都大塞車。後來又找了一天再試一次。\n 測試日期：2020年8月29日     地點 時間     起點 17:15   板橋車站（文化路） 18:00   板橋車站站體 18:03   終點 18:05    費時50分鐘。板橋的下班尖峰時間無論是晴是雨、是不是週五都會塞車，而且930在下交流道後會在市區繞一陣子才會到板橋車站，但有座位腿也比較不會痠。\n結論 就乘車時間而言，板南線與環狀線差異不大，930公車在尖峰時間明顯偏慢，不過如果要到板橋車站以前的站牌就可以免去在市區繞行的時間，或是在離峰時間搭930乘車時間也許不比捷運差。\n就價格而言，截至2020年8月，捷運原價是NT$35，公車原價是NT$15，公車票價大勝捷運。\n最終還是要看自己的需求。起終點只要差一些，通車成本就會差很多。\n","description":"","subtitle":"環狀線真的會比較快嗎","title":"[交通] 新店到板橋怎麼去","uri":"/posts/transportation-xindian-banqiao/"},{"categories":["hugo"],"content":"利用Hugo架網站其實不難（MacOS），只是若想要讓網站成為自己心目中的版面還要多花一些功夫就是了。Hugo官網上也有簡單的教學，讓使用者可以快速架設Hugo網站。\nWindows作業系統可以參考這篇。\nHugo簡介 Hugo是由Go寫成的靜態網頁產生器（static site generator），網站主要內容以Markdown格式撰寫，經Hugo編譯成HTML後可供瀏覽器瀏覽，其最大的優點為建置速度相較於其他靜態網頁產生器（如Jekyll）快上許多，另外便是其英文教學文檔還算清楚。\n安裝Hugo 在MacOS或Linux環境下安裝相對簡單。\n1  brew install hugo   不知道什麼是brew的人可以參考Homebrew的官網。\n安裝後確認是否安裝成功：\n1 2  $ hugo version Hugo Static Site Generator v0.74.3/extended darwin/amd64 BuildDate: unknown   版本號可能會不一樣，只要不要輸出錯誤訊息就好了。\n建立新網站 1  hugo new site my_site   my_site是專案資料夾的名稱，可以自己決定。\n加入主題 Hugo沒有預設主題，必須要加入主題才能使網站運作。Hugo蒐集了許多的主題（theme），可以選擇自己喜歡的主題下載。這邊以Axiom為例。\n1 2 3  cd my_site git init git submodule add https://github.com/marketempower/axiom.git themes/axiom   如果不想用git的話，也可以直接去GitHub下載整個專案，並放置在themes資料夾中。\n如果想要以某個主題為基礎來創建新主題，也可以直接下載或以git clone、git subtree的方式處理。官方的建議是用git submodule。\n如果確定要用該主題，可以在配置檔config.toml加入theme = \"axiom\"：\n1  echo 'theme = \"axiom\"' \u003e\u003e config.toml   或著可以在預覽階段指定主題。\n通常每個主題都會附上範例網頁，部分主題還會有說明文檔，可以各主題的範例網頁做為選擇的參考。\n新增頁面 1  hugo new posts/my-first-post.md   Hugo會在content資料夾下建立posts/my-first-post.md，打開後會發現裡面有關於頁面建立時間的資訊，可以在其下方隨意加入一些內容。\n預覽 開啟Hugo server便可預覽目前的成果：\n1  hugo server -D   -D表示預覽所有非草稿及草稿（標註draft = true）頁面。如果沒在config.toml加入theme = \"axiom\"，可以在開啟server時指定主題：\n1  hugo server -t axiom   接著在任何瀏覽器輸入http://localhost:1313/以預覽網站；在終端機按Ctrl+C便可關閉server。\n在預覽過程中可能會發現和主題作者所提供的範例頁面有所出入（某部分無法順利顯示等），這便要視各主題有沒有要求任何必要變數使模板順利運作。如果原作者有提供說明文檔或範例頁面的原始碼，就可以藉此推敲出其中的端倪。\n建立靜態網頁 在所有設定（配置檔內容、草稿與否等）都配置好的情況下便可直接執行以下指令：\n1  hugo   Hugo會建立public目錄，其內容包括靜態網頁所需的HTML、CSS、JS檔。hugo指令亦可藉flags（-D、-t等）輔助配置。\n參考資料  Quick Start _ Hugo 透過Hugo快速建置個人Blog - Carson’s Tech Note  ","description":"","subtitle":"少許步驟輕鬆上手","title":"[Hugo] 架站步驟分享","uri":"/posts/hugo-steps-share/"},{"categories":["ruby"],"content":"「三等號（===）」和「雙等號（==）」是許多Ruby初學者經常搞混的兩個運算子。一些類別會根據自己的需要而覆寫三等號。本篇會介紹三等號===的用法。\n物件相等性 三等號只有在Object#===時與Object#==相等。\n1 2 3 4  s1 = \"apple\" s2 = \"apple\" s1 == s2 # =\u003e true s1 === s2 # =\u003e true   型態匹配 Module類別覆寫了三等號，使其可以確認物件的型態。例如：\n1 2 3 4 5 6 7 8  3.is_a? Integer # =\u003e true Integer === 3 # =\u003e true \"apple\".is_a? Integer # =\u003e false Integer === \"apple\" # =\u003e false Module === Object # =\u003e true Object === Module # =\u003e true   範圍匹配 Range類別亦覆寫了三等號，使其可以確認物件是否在範圍內。例如：\n1 2 3 4 5  (0...3).include? 0 # =\u003e true (0...3) === 0 # =\u003e true (\"a\"...\"z\").include? \"z\" # =\u003e false (\"a\"...\"z\") === \"z\" # =\u003e false   字串匹配 Regexp類別也覆寫了三等號，使其可以確認字串是否符合正規表示式（Regular Expression）。例如：\n1 2  /a+/ =~ \"apple\" # =\u003e 0 /a+/ === \"apple\" # =\u003e true   Proc#call 若左手邊是Proc類別的物件，則其功能等同於Proc#call。例如：\n1 2 3  cube = Proc.new { |x| x ** 3 } cube.call 3 # =\u003e 27 cube === 3 # =\u003e 27   Case Equality Operator 三等號有一個名稱叫「Case Equality Operator」。在case...when...else中，when便會呼叫===來匹配，使程式碼更簡潔。\n1 2 3 4 5 6 7 8  case score when 0...60 \"failed\" when 60..100 \"passed\" else \"wrong score\" end   整理 以下整理各類三等號的等同方法。\n   類 方法     Object #==, #eql?   Module #is_a?, #kind_of?   Range #include?, #member?   Regexp (#=~)（不完全相同）   Proc #call, #yield, #[]    參考資料  Class_ Object (Ruby 2.6.3) Class_ Module (Ruby 2.5.3) Class_ Range (Ruby 2.7.1) Class_ Regexp (Ruby 2.7.1) Class_ Proc (Ruby 2.7.1)  ","description":"","subtitle":"披著等號外皮的多功能運算子","title":"[Ruby] 「===」和「==」一樣嗎？","uri":"/posts/ruby-triple-equals/"},{"categories":["ruby"],"content":"寫程式時無可避免的就是兩個物件或變數是否相等，而Ruby提供一些方法來確認其相等性。\n比較運算子 比較兩物件是否相等時可以使用雙等號（==），相等時返回true，反之則返回false。不等於則使用不等於運算子（!=）。通常實作自定義類別時會覆寫這兩個方法。\n1 2 3 4 5 6 7 8 9  s1 = \"apple\" s2 = \"apple\" s1 == s2 # =\u003e true s1 != s2 # =\u003e false a1 = [\"apple\", \"banana\"] a2 = [\"apple\", \"banana\"] a1 == a2 # =\u003e true a1 != a2 # =\u003e false   不同型態的數字也可以使用雙等號。例如：\n1 2 3  i = 1 f = 1.0 i == f # =\u003e true   equal? equal?方法比較兩個變數是否參考至同一物件，因此在實作自定義類別時不應覆寫equal?方法。\n1 2 3 4 5 6 7 8  s1 = \"apple\" s2 = \"apple\" s1.object_id == s2.object_id # =\u003e false s1.equal? s2 # =\u003e false s2 = s1 s1.object_id == s2.object_id # =\u003e true s1.equal? s2 # =\u003e true   eql? eql?方法比較兩物件的雜湊值（hash value）是否相等。對於Object類別的物件而言，eql?和==是相同的。通常在實作自定義類別時，亦會使eql?和==的返回值相等以保持這樣的慣例。\nNumeric類別則是其中的一個例外。\n1 2 3  1 == 1.0 # =\u003e true 1.hash == 1.0.hash # =\u003e false 1.eql? 1.0 # =\u003e false   那===呢 Object#===與==同功能，其子類別會依據需求而覆寫此方法，下一篇再詳細說明。\n參考資料  Class_ BasicObject (Ruby 2.6.3) Difference Between ==, eql_, equal_ in ruby _ by Khalidh Sd _ Medium  ","description":"","subtitle":"2分鐘了解它們的區別！","title":"[Ruby] ==、equal?、和eql?差在哪裡？","uri":"/posts/ruby-comparison-methods/"}]